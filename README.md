# Algos and DS by Colt Steele

- [Algos and DS by Colt Steele](#algos-and-ds-by-colt-steele)
  - [Lessons](#lessons)
  - [Notes](#notes)

## Lessons

- [x] ~~_Part 1: Big O Intro_~~ [2023-11-22]
  - [x] ~~_Lesson 001: Curriculum Overview_~~ [2023-11-22]
  - [x] ~~_Lesson 002: What Order Should You Watch In?_~~ [2023-11-22]
  - [x] ~~_Lesson 003 - How I'm Running My Code_~~ [2023-11-22]
  - [x] ~~_Lesson 004 - Intro to Big O_~~ [2023-11-22]
  - [x] ~~_Lesson 005 - Timing Our Code_~~ [2023-11-22]
  - [x] ~~_Lesson 006 - Counting Operations - 5min_~~ [2023-11-22]
  - [x] ~~_Lesson 007 - Visualizing Time Complexities - 4min_~~ [2023-11-22]
  - [x] ~~_Lesson 008 - Official Intro to Big O - 10min_~~ [2023-11-22]
  - [x] ~~_Lesson 009 - Simplifying Big O Expressions - 10min_~~ [2023-11-22]
  - [x] ~~_Lesson 010 - Space Complexity - 6min_~~ [2023-11-22]
  - [x] ~~_Lesson 011 - Logs and Section Recap - 9min_~~ [2023-11-22]
  - [x] ~~_Lesson 012 - Section Introduction - 2min_~~ [2023-11-22]
  - [x] ~~_Lesson 013 - The Big O of Objects - 6min_~~ [2023-11-22]
  - [x] ~~_Lesson 014 - When Are Arrays Slow - 6min_~~ [2023-11-22]
  - [x] ~~_Lesson 015 - Big O Array Methods - 6min_~~ [2023-11-22]
- [x] ~~_Part 2: Problem Solving Fundamentals - 61min_~~ [2023-11-22]
  - [x] ~~_Lesson 016 - Introduction to Problem Solving - 7min_~~ [2023-11-22]
  - [x] ~~_Lesson 017 - Step 1: Understand the Problem - 8min_~~ [2023-11-22]
  - [x] ~~_Lesson 018 - Step 2: Concrete Problems - 6min_~~ [2023-11-22]
  - [x] ~~_Lesson 019 - Step 3: Break It Down - 8min_~~ [2023-11-22]
  - [x] ~~_Lesson 020 - Step 4: Solve Or Simplify - 11min_~~ [2023-11-22]
  - [x] ~~_Lesson 021 - Step 5: Look Back and Refactor - 17min_~~ [2023-11-22]
  - [x] ~~_Lesson 022 - Recap and Interview Strategies - 4min_~~ [2023-11-22]
- [ ] Part 3: Problem Solving Patterns - 114min
  - [x] ~~_Lesson 023 - Intro to Problem Solving Patterns - 3min_~~ [2023-11-22]
  - [x] ~~_Lesson 024 - Frequency Counter Problem - 15min_~~ [2023-11-22]
  - [x] ~~_Lesson 025 - Frequency Counter & Anagram Challenge - 3min_~~ [2023-11-22]
  - [x] ~~_Lesson 026 - Anagram Challenge Solution - 6min_~~ [2023-11-22]
  - [x] ~~_Lesson 027 - Multiple Pointers Pattern - 10min_~~ [2023-11-22]
  - [x] ~~_Lesson 028 - Multiple Pointers: Count Unique Values Challenger - 5min_~~ [2023-11-24]
  - [x] ~~_Lesson 029 - Count Unique Value Challenge Solution - 7min_~~ [2023-11-24]
  - [x] ~~_Lesson 030 - Sliding Window Pattern - 13min_~~ [2023-11-24]
  - [x] ~~_Lesson 031 - Divide And Conquer Pattern - 7min_~~ [2023-11-24]
  - [ ] Lesson 032 - Story Time: Martin & The Dragon - 7min
  - [ ] Lesson 033 - Why Use Recursion? - 6min
  - [ ] Lesson 034 - The Call Stack - 7min
  - [ ] Lesson 035 - Our First Recursive Function - 5min
  - [ ] Lesson 036 - Our Second Recursive Function - 8min
  - [ ] Lesson 037 - Writing Factorial Iteratively - 2min
  - [ ] Lesson 038 - Writing Factorial Recursively - 3min
  - [ ] Lesson 039 - Common Recursion Pitfalls - 5min
  - [ ] Lesson 040 - Helper Method Recursion - 6min
  - [ ] Lesson 041 - Pure Recursion - 8min
- [ ] Part 4: Search
  - [ ] Lesson 042 - Intro to Searching
  - [ ] Lesson 043 - Intro to Linear Search
  - [ ] Lesson 044 - Linear Search Solution
  - [ ] Lesson 045 - Linear Search Big O
  - [ ] Lesson 046 - Intro to Binary Search
  - [ ] Lesson 047 - Binary Search PseudoCode
  - [ ] Lesson 048 - Binary Search Solution
  - [ ] Lesson 049 - Binary Search Big O
  - [ ] Lesson 050 - Naive String Search
  - [ ] Lesson 051 - Naive String Search Implementation
- [ ] Part 5: Sorting
  - [ ] Lesson 052 - Introduction to Sorting Algorithms
  - [ ] Lesson 053 - Built-in JavaScript Sorting
  - [ ] Lesson 054 - Bubble Sort: Overview
  - [ ] Lesson 055 - Bubble Sort: Implementation
  - [ ] Lesson 056 - Bubble Sort: Optimization
  - [ ] Lesson 057 - Bubble Sort: Big O Complexity

## Notes

- Part 1 Notes:
  - O(1), O(log(n)), O(n), O(n \* log(n)), O(n^2)
  - Time Complexity, Space Complexity
- Part 2 Notes:
  - An `algorithm` is a well-defined set of instructions to complete a task
  - George Polya's `How To Solve It`
  - Step 1: Understand the Problem
    - 1. `Can I restate the problems in my own words`
    - 2. `What are the inputs that go into the problem`
    - 3. `What are the outputs of a solution`
    - 4. `Can the outputs be derived from the inputs? (Is it solvable?)`
    - 5. `What important parts of the problem be labeled?`
  - Step 2: Exploring Concrete Examples
    - 1. Start with simple examples
    - 2. Progress to more complex examples
    - 3. Examples with empty inputs
    - 4. Examples with invalid inputs
  - Step 3: Break it down
    - 1. Explicitly write out the steps you need to take
- Part 3 Notes:
  - `Frequency Counter`
    - the use of objects/sets to count the frequency of data occurring
    - Usually results in O(n) efficiency gain over nested loop solutions O(n^2)
  - `Multiple Pointers`
    - keep track of a `position` or `index` and then progress pointer toward ending condition
  - `Sliding Window`
    - Useful for keeping track of a subset of data in array or string
    - Window grows or closes (and a new window is opened) based on some tracking condition
